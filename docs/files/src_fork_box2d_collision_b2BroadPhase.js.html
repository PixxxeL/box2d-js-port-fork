<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\fork\box2d\collision\b2BroadPhase.js - Box2D Port Fork API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Box2D Port Fork API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/b2AABB.html">b2AABB</a></li>
            
                <li><a href="../classes/b2Body.html">b2Body</a></li>
            
                <li><a href="../classes/b2BodyDef.html">b2BodyDef</a></li>
            
                <li><a href="../classes/b2Bound.html">b2Bound</a></li>
            
                <li><a href="../classes/b2BoundValues.html">b2BoundValues</a></li>
            
                <li><a href="../classes/b2BoxDef.html">b2BoxDef</a></li>
            
                <li><a href="../classes/b2BufferedPair.html">b2BufferedPair</a></li>
            
                <li><a href="../classes/b2CircleContact.html">b2CircleContact</a></li>
            
                <li><a href="../classes/b2CircleDef.html">b2CircleDef</a></li>
            
                <li><a href="../classes/b2CircleShape.html">b2CircleShape</a></li>
            
                <li><a href="../classes/b2Collision.html">b2Collision</a></li>
            
                <li><a href="../classes/b2CollisionFilter.html">b2CollisionFilter</a></li>
            
                <li><a href="../classes/b2Conservative.html">b2Conservative</a></li>
            
                <li><a href="../classes/b2Contact.html">b2Contact</a></li>
            
                <li><a href="../classes/b2ContactConstraint.html">b2ContactConstraint</a></li>
            
                <li><a href="../classes/b2ContactConstraintPoint.html">b2ContactConstraintPoint</a></li>
            
                <li><a href="../classes/b2ContactID.html">b2ContactID</a></li>
            
                <li><a href="../classes/b2ContactManager.html">b2ContactManager</a></li>
            
                <li><a href="../classes/b2ContactNode.html">b2ContactNode</a></li>
            
                <li><a href="../classes/b2ContactPoint.html">b2ContactPoint</a></li>
            
                <li><a href="../classes/b2ContactRegister.html">b2ContactRegister</a></li>
            
                <li><a href="../classes/b2ContactSolver.html">b2ContactSolver</a></li>
            
                <li><a href="../classes/b2Distance.html">b2Distance</a></li>
            
                <li><a href="../classes/b2DistanceJoint.html">b2DistanceJoint</a></li>
            
                <li><a href="../classes/b2DistanceJointDef.html">b2DistanceJointDef</a></li>
            
                <li><a href="../classes/b2GearJoint.html">b2GearJoint</a></li>
            
                <li><a href="../classes/b2GearJointDef.html">b2GearJointDef</a></li>
            
                <li><a href="../classes/b2Island.html">b2Island</a></li>
            
                <li><a href="../classes/b2Jacobian.html">b2Jacobian</a></li>
            
                <li><a href="../classes/b2Joint.html">b2Joint</a></li>
            
                <li><a href="../classes/b2JointDef.html">b2JointDef</a></li>
            
                <li><a href="../classes/b2JointNode.html">b2JointNode</a></li>
            
                <li><a href="../classes/b2Manifold.html">b2Manifold</a></li>
            
                <li><a href="../classes/b2MassData.html">b2MassData</a></li>
            
                <li><a href="../classes/b2Mat22.html">b2Mat22</a></li>
            
                <li><a href="../classes/b2Math.html">b2Math</a></li>
            
                <li><a href="../classes/b2MouseJoint.html">b2MouseJoint</a></li>
            
                <li><a href="../classes/b2MouseJointDef.html">b2MouseJointDef</a></li>
            
                <li><a href="../classes/b2NullContact.html">b2NullContact</a></li>
            
                <li><a href="../classes/b2OBB.html">b2OBB</a></li>
            
                <li><a href="../classes/b2Pair.html">b2Pair</a></li>
            
                <li><a href="../classes/b2PairCallback.html">b2PairCallback</a></li>
            
                <li><a href="../classes/b2PairManager.html">b2PairManager</a></li>
            
                <li><a href="../classes/b2PolyAndCircleContact.html">b2PolyAndCircleContact</a></li>
            
                <li><a href="../classes/b2PolyContact.html">b2PolyContact</a></li>
            
                <li><a href="../classes/b2PolyDef.html">b2PolyDef</a></li>
            
                <li><a href="../classes/b2PolyShape.html">b2PolyShape</a></li>
            
                <li><a href="../classes/b2PrismaticJoint.html">b2PrismaticJoint</a></li>
            
                <li><a href="../classes/b2PrismaticJointDef.html">b2PrismaticJointDef</a></li>
            
                <li><a href="../classes/b2Proxy.html">b2Proxy</a></li>
            
                <li><a href="../classes/b2PulleyJoint.html">b2PulleyJoint</a></li>
            
                <li><a href="../classes/b2PulleyJointDef.html">b2PulleyJointDef</a></li>
            
                <li><a href="../classes/b2RevoluteJoint.html">b2RevoluteJoint</a></li>
            
                <li><a href="../classes/b2RevoluteJointDef.html">b2RevoluteJointDef</a></li>
            
                <li><a href="../classes/b2Settings.html">b2Settings</a></li>
            
                <li><a href="../classes/b2Shape.html">b2Shape</a></li>
            
                <li><a href="../classes/b2ShapeDef.html">b2ShapeDef</a></li>
            
                <li><a href="../classes/b2TimeStep.html">b2TimeStep</a></li>
            
                <li><a href="../classes/b2Vec2.html">b2Vec2</a></li>
            
                <li><a href="../classes/b2World.html">b2World</a></li>
            
                <li><a href="../classes/b2WorldListener.html">b2WorldListener</a></li>
            
                <li><a href="../classes/ClipVertex.html">ClipVertex</a></li>
            
                <li><a href="../classes/Features.html">Features</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\fork\box2d\collision\b2BroadPhase.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿/*
* Copyright (c) 2006-2007 Erin Catto http:
*
* This software is provided &#x27;as-is&#x27;, without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked, and must not be
* misrepresented the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

/**
 * This broad phase uses the Sweep and Prune algorithm in:
 * Collision Detection in Interactive 3D Environments by Gino van den Bergen
 * Also, some ideas, such integral values for fast compares comes from
 * Bullet (http:/www.bulletphysics.com).
 * 
 * Notes:
 * - we use bound arrays instead of linked lists for cache coherence.
 * - we use quantized integral values for fast compares.
 * - we use short indices rather than pointers to save memory.
 * - we use a stabbing count for fast overlap queries (less than order N).
 * - we also use a time stamp on each proxy to speed up the registration of
 *   overlap query results.
 * - where possible, we compare bound indices instead of values to reduce
 *   cache misses (TODO_ERIN).
 * - no broadphase is perfect and neither is this one: it is not great for huge
 *   worlds (use a multi-SAP instead), it is not great for large objects.
 * 
 * @class b2Bound
 * @constructor
 */
var b2BroadPhase = function (worldAABB, callback) {
    // initialize instance variables for references
	this.m_pairManager = new b2PairManager();
	this.m_proxyPool = new Array(b2Settings.b2_maxPairs);
	this.m_bounds = new Array(2*b2Settings.b2_maxProxies);
	this.m_queryResults = new Array(b2Settings.b2_maxProxies);
	this.m_quantizationFactor = new b2Vec2();
	//

	//b2Settings.b2Assert(worldAABB.IsValid());
	var i = 0;

	this.m_pairManager.Initialize(this, callback);

	this.m_worldAABB = worldAABB;

	this.m_proxyCount = 0;

	// query results
	for (i = 0; i &lt; b2Settings.b2_maxProxies; i++){
		this.m_queryResults[i] = 0;
	}

	// bounds array
	this.m_bounds = new Array(2);
	for (i = 0; i &lt; 2; i++){
		this.m_bounds[i] = new Array(2*b2Settings.b2_maxProxies);
		for (var j = 0; j &lt; 2*b2Settings.b2_maxProxies; j++){
			this.m_bounds[i][j] = new b2Bound();
		}
	}

	//var d = b2Math.SubtractVV(worldAABB.maxVertex, worldAABB.minVertex);
	var dX = worldAABB.maxVertex.x;
	var dY = worldAABB.maxVertex.y;
	dX -= worldAABB.minVertex.x;
	dY -= worldAABB.minVertex.y;

	this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
	this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;

	var tProxy;
	for (i = 0; i &lt; b2Settings.b2_maxProxies - 1; ++i)
	{
		tProxy = new b2Proxy();
		this.m_proxyPool[i] = tProxy;
		tProxy.SetNext(i + 1);
		tProxy.timeStamp = 0;
		tProxy.overlapCount = b2BroadPhase.b2_invalid;
		tProxy.userData = null;
	}
	tProxy = new b2Proxy();
	this.m_proxyPool[b2Settings.b2_maxProxies-1] = tProxy;
	tProxy.SetNext(b2Pair.b2_nullProxy);
	tProxy.timeStamp = 0;
	tProxy.overlapCount = b2BroadPhase.b2_invalid;
	tProxy.userData = null;
	this.m_freeProxy = 0;

	this.m_timeStamp = 1;
	this.m_queryResultCount = 0;
};
b2BroadPhase.prototype = 
{
//public:
	//~b2BroadPhase();

	// Use this to see if your proxy is in range. If it is not in range,
	// it should be destroyed. Otherwise you may get O(m^2) pairs, where m
	// is the number of proxies that are out of range.
	InRange: function(aabb){
		//var d = b2Math.b2MaxV(b2Math.SubtractVV(aabb.minVertex, this.m_worldAABB.maxVertex), b2Math.SubtractVV(this.m_worldAABB.minVertex, aabb.maxVertex));
		var dX;
		var dY;
		var d2X;
		var d2Y;

		dX = aabb.minVertex.x;
		dY = aabb.minVertex.y;
		dX -= this.m_worldAABB.maxVertex.x;
		dY -= this.m_worldAABB.maxVertex.y;

		d2X = this.m_worldAABB.minVertex.x;
		d2Y = this.m_worldAABB.minVertex.y;
		d2X -= aabb.maxVertex.x;
		d2Y -= aabb.maxVertex.y;

		dX = b2Math.b2Max(dX, d2X);
		dY = b2Math.b2Max(dY, d2Y);

		return b2Math.b2Max(dX, dY) &lt; 0.0;
	},

	// Get a single proxy. Returns NULL if the id is invalid.
	GetProxy: function(proxyId){
		if (proxyId == b2Pair.b2_nullProxy || this.m_proxyPool[proxyId].IsValid() == false)
		{
			return null;
		}

		return this.m_proxyPool[ proxyId ];
	},

	// Create and destroy proxies. These call Flush first.
	CreateProxy: function(aabb, userData){
		var index = 0;
		var proxy;

		//b2Settings.b2Assert(this.m_proxyCount &lt; b2_maxProxies);
		//b2Settings.b2Assert(this.m_freeProxy != b2Pair.b2_nullProxy);

		var proxyId = this.m_freeProxy;
		proxy = this.m_proxyPool[ proxyId ];
		this.m_freeProxy = proxy.GetNext();

		proxy.overlapCount = 0;
		proxy.userData = userData;

		var boundCount = 2 * this.m_proxyCount;

		var lowerValues = new Array();
		var upperValues = new Array();
		this.ComputeBounds(lowerValues, upperValues, aabb);

		for (var axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];
			var lowerIndex = 0;
			var upperIndex = 0;
			var lowerIndexOut = [lowerIndex];
			var upperIndexOut = [upperIndex];
			this.Query(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
			lowerIndex = lowerIndexOut[0];
			upperIndex = upperIndexOut[0];

			// Replace memmove calls
			//memmove(bounds + upperIndex + 2, bounds + upperIndex, (edgeCount - upperIndex) * sizeof(b2Bound));
			var tArr = new Array();
			var j = 0;
			var tEnd = boundCount - upperIndex
			var tBound1;
			var tBound2;
			// make temp array
			for (j = 0; j &lt; tEnd; j++){
				tArr[j] = new b2Bound();
				tBound1 = tArr[j];
				tBound2 = bounds[upperIndex+j];
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			// move temp array back in to bounds
			tEnd = tArr.length;
			var tIndex = upperIndex+2;
			for (j = 0; j &lt; tEnd; j++){
				//bounds[tIndex+j] = tArr[j];
				tBound2 = tArr[j];
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			//memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound));
			// make temp array
			tArr = new Array();
			tEnd = upperIndex - lowerIndex;
			for (j = 0; j &lt; tEnd; j++){
				tArr[j] = new b2Bound();
				tBound1 = tArr[j];
				tBound2 = bounds[lowerIndex+j];
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			// move temp array back in to bounds
			tEnd = tArr.length;
			tIndex = lowerIndex+1;
			for (j = 0; j &lt; tEnd; j++){
				//bounds[tIndex+j] = tArr[j];
				tBound2 = tArr[j];
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}

			// The upper index has increased because of the lower bound insertion.
			++upperIndex;

			// Copy in the new bounds.
			bounds[lowerIndex].value = lowerValues[axis];
			bounds[lowerIndex].proxyId = proxyId;
			bounds[upperIndex].value = upperValues[axis];
			bounds[upperIndex].proxyId = proxyId;

			bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount;
			bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount;

			// Adjust the stabbing count between the new bounds.
			for (index = lowerIndex; index &lt; upperIndex; ++index)
			{
				bounds[index].stabbingCount++;
			}

			// Adjust the all the affected bound indices.
			for (index = lowerIndex; index &lt; boundCount + 2; ++index)
			{
				var proxy2 = this.m_proxyPool[ bounds[index].proxyId ];
				if (bounds[index].IsLower())
				{
					proxy2.lowerBounds[axis] = index;
				}
				else
				{
					proxy2.upperBounds[axis] = index;
				}
			}
		}

		++this.m_proxyCount;

		//b2Settings.b2Assert(this.m_queryResultCount &lt; b2Settings.b2_maxProxies);

		for (var i = 0; i &lt; this.m_queryResultCount; ++i)
		{
			//b2Settings.b2Assert(this.m_queryResults[i] &lt; b2_maxProxies);
			//b2Settings.b2Assert(this.m_proxyPool[this.m_queryResults[i]].IsValid());

			this.m_pairManager.AddBufferedPair(proxyId, this.m_queryResults[i]);
		}

		this.m_pairManager.Commit();

		// Prepare for next query.
		this.m_queryResultCount = 0;
		this.IncrementTimeStamp();

		return proxyId;
	},

	DestroyProxy: function(proxyId){

		//b2Settings.b2Assert(0 &lt; this.m_proxyCount &amp;&amp; this.m_proxyCount &lt;= b2_maxProxies);

		var proxy = this.m_proxyPool[ proxyId ];
		//b2Settings.b2Assert(proxy.IsValid());

		var boundCount = 2 * this.m_proxyCount;

		for (var axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];

			var lowerIndex = proxy.lowerBounds[axis];
			var upperIndex = proxy.upperBounds[axis];
			var lowerValue = bounds[lowerIndex].value;
			var upperValue = bounds[upperIndex].value;

			// replace memmove calls
			//memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound));
			var tArr = new Array();
			var j = 0;
			var tEnd = upperIndex - lowerIndex - 1;
			var tBound1;
			var tBound2;
			// make temp array
			for (j = 0; j &lt; tEnd; j++){
				tArr[j] = new b2Bound();
				tBound1 = tArr[j];
				tBound2 = bounds[lowerIndex+1+j];
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			// move temp array back in to bounds
			tEnd = tArr.length;
			var tIndex = lowerIndex;
			for (j = 0; j &lt; tEnd; j++){
				//bounds[tIndex+j] = tArr[j];
				tBound2 = tArr[j];
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			//memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (edgeCount - upperIndex - 1) * sizeof(b2Bound));
			// make temp array
			tArr = new Array();
			tEnd = boundCount - upperIndex - 1;
			for (j = 0; j &lt; tEnd; j++){
				tArr[j] = new b2Bound();
				tBound1 = tArr[j];
				tBound2 = bounds[upperIndex+1+j];
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}
			// move temp array back in to bounds
			tEnd = tArr.length;
			tIndex = upperIndex-1;
			for (j = 0; j &lt; tEnd; j++){
				//bounds[tIndex+j] = tArr[j];
				tBound2 = tArr[j];
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value;
				tBound1.proxyId = tBound2.proxyId;
				tBound1.stabbingCount = tBound2.stabbingCount;
			}

			// Fix bound indices.
			tEnd = boundCount - 2;
			for (var index = lowerIndex; index &lt; tEnd; ++index)
			{
				var proxy2 = this.m_proxyPool[ bounds[index].proxyId ];
				if (bounds[index].IsLower())
				{
					proxy2.lowerBounds[axis] = index;
				}
				else
				{
					proxy2.upperBounds[axis] = index;
				}
			}

			// Fix stabbing count.
			tEnd = upperIndex - 1;
			for (var index2 = lowerIndex; index2 &lt; tEnd; ++index2)
			{
				bounds[index2].stabbingCount--;
			}

			// this.Query for pairs to be removed. lowerIndex and upperIndex are not needed.
			// make lowerIndex and upper output using an array and do this for others if compiler doesn&#x27;t pick them up
			this.Query([0], [0], lowerValue, upperValue, bounds, boundCount - 2, axis);
		}

		//b2Settings.b2Assert(this.m_queryResultCount &lt; b2Settings.b2_maxProxies);

		for (var i = 0; i &lt; this.m_queryResultCount; ++i)
		{
			//b2Settings.b2Assert(this.m_proxyPool[this.m_queryResults[i]].IsValid());

			this.m_pairManager.RemoveBufferedPair(proxyId, this.m_queryResults[i]);
		}

		this.m_pairManager.Commit();

		// Prepare for next query.
		this.m_queryResultCount = 0;
		this.IncrementTimeStamp();

		// Return the proxy to the pool.
		proxy.userData = null;
		proxy.overlapCount = b2BroadPhase.b2_invalid;
		proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
		proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
		proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
		proxy.upperBounds[1] = b2BroadPhase.b2_invalid;

		proxy.SetNext(this.m_freeProxy);
		this.m_freeProxy = proxyId;
		--this.m_proxyCount;
	},


	// Call this.MoveProxy times like, then when you are done
	// call this.Commit to finalized the proxy pairs (for your time step).
	MoveProxy: function(proxyId, aabb){
		var axis = 0;
		var index = 0;
		var bound;
		var prevBound
		var nextBound
		var nextProxyId = 0;
		var nextProxy;

		if (proxyId == b2Pair.b2_nullProxy || b2Settings.b2_maxProxies &lt;= proxyId)
		{
			//b2Settings.b2Assert(false);
			return;
		}

		if (aabb.IsValid() == false)
		{
			//b2Settings.b2Assert(false);
			return;
		}

		var boundCount = 2 * this.m_proxyCount;

		var proxy = this.m_proxyPool[ proxyId ];
		// Get new bound values
		var newValues = new b2BoundValues();
		this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);

		// Get old bound values
		var oldValues = new b2BoundValues();
		for (axis = 0; axis &lt; 2; ++axis)
		{
			oldValues.lowerValues[axis] = this.m_bounds[axis][proxy.lowerBounds[axis]].value;
			oldValues.upperValues[axis] = this.m_bounds[axis][proxy.upperBounds[axis]].value;
		}

		for (axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];

			var lowerIndex = proxy.lowerBounds[axis];
			var upperIndex = proxy.upperBounds[axis];

			var lowerValue = newValues.lowerValues[axis];
			var upperValue = newValues.upperValues[axis];

			var deltaLower = lowerValue - bounds[lowerIndex].value;
			var deltaUpper = upperValue - bounds[upperIndex].value;

			bounds[lowerIndex].value = lowerValue;
			bounds[upperIndex].value = upperValue;

			//
			// Expanding adds overlaps
			//

			// Should we move the lower bound down?
			if (deltaLower &lt; 0)
			{
				index = lowerIndex;
				while (index &gt; 0 &amp;&amp; lowerValue &lt; bounds[index-1].value)
				{
					bound = bounds[index];
					prevBound = bounds[index - 1];

					var prevProxyId = prevBound.proxyId;
					var prevProxy = this.m_proxyPool[ prevBound.proxyId ];

					prevBound.stabbingCount++;

					if (prevBound.IsUpper() == true)
					{
						if (this.TestOverlap(newValues, prevProxy))
						{
							this.m_pairManager.AddBufferedPair(proxyId, prevProxyId);
						}

						prevProxy.upperBounds[axis]++;
						bound.stabbingCount++;
					}
					else
					{
						prevProxy.lowerBounds[axis]++;
						bound.stabbingCount--;
					}

					proxy.lowerBounds[axis]--;

					// swap
					//var temp = bound;
					//bound = prevEdge;
					//prevEdge = temp;
					bound.Swap(prevBound);
					//b2Math.b2Swap(bound, prevEdge);
					--index;
				}
			}

			// Should we move the upper bound up?
			if (deltaUpper &gt; 0)
			{
				index = upperIndex;
				while (index &lt; boundCount-1 &amp;&amp; bounds[index+1].value &lt;= upperValue)
				{
					bound = bounds[ index ];
					nextBound = bounds[ index + 1 ];
					nextProxyId = nextBound.proxyId;
					nextProxy = this.m_proxyPool[ nextProxyId ];

					nextBound.stabbingCount++;

					if (nextBound.IsLower() == true)
					{
						if (this.TestOverlap(newValues, nextProxy))
						{
							this.m_pairManager.AddBufferedPair(proxyId, nextProxyId);
						}

						nextProxy.lowerBounds[axis]--;
						bound.stabbingCount++;
					}
					else
					{
						nextProxy.upperBounds[axis]--;
						bound.stabbingCount--;
					}

					proxy.upperBounds[axis]++;
					// swap
					//var temp = bound;
					//bound = nextEdge;
					//nextEdge = temp;
					bound.Swap(nextBound);
					//b2Math.b2Swap(bound, nextEdge);
					index++;
				}
			}

			//
			// Shrinking removes overlaps
			//

			// Should we move the lower bound up?
			if (deltaLower &gt; 0)
			{
				index = lowerIndex;
				while (index &lt; boundCount-1 &amp;&amp; bounds[index+1].value &lt;= lowerValue)
				{
					bound = bounds[ index ];
					nextBound = bounds[ index + 1 ];

					nextProxyId = nextBound.proxyId;
					nextProxy = this.m_proxyPool[ nextProxyId ];

					nextBound.stabbingCount--;

					if (nextBound.IsUpper())
					{
						if (this.TestOverlap(oldValues, nextProxy))
						{
							this.m_pairManager.RemoveBufferedPair(proxyId, nextProxyId);
						}

						nextProxy.upperBounds[axis]--;
						bound.stabbingCount--;
					}
					else
					{
						nextProxy.lowerBounds[axis]--;
						bound.stabbingCount++;
					}

					proxy.lowerBounds[axis]++;
					// swap
					//var temp = bound;
					//bound = nextEdge;
					//nextEdge = temp;
					bound.Swap(nextBound);
					//b2Math.b2Swap(bound, nextEdge);
					index++;
				}
			}

			// Should we move the upper bound down?
			if (deltaUpper &lt; 0)
			{
				index = upperIndex;
				while (index &gt; 0 &amp;&amp; upperValue &lt; bounds[index-1].value)
				{
					bound = bounds[index];
					prevBound = bounds[index - 1];

					prevProxyId = prevBound.proxyId;
					prevProxy = this.m_proxyPool[ prevProxyId ];

					prevBound.stabbingCount--;

					if (prevBound.IsLower() == true)
					{
						if (this.TestOverlap(oldValues, prevProxy))
						{
							this.m_pairManager.RemoveBufferedPair(proxyId, prevProxyId);
						}

						prevProxy.lowerBounds[axis]++;
						bound.stabbingCount--;
					}
					else
					{
						prevProxy.upperBounds[axis]++;
						bound.stabbingCount++;
					}

					proxy.upperBounds[axis]--;
					// swap
					//var temp = bound;
					//bound = prevEdge;
					//prevEdge = temp;
					bound.Swap(prevBound);
					//b2Math.b2Swap(bound, prevEdge);
					index--;
				}
			}
		}
	},

	Commit: function(){
		this.m_pairManager.Commit();
	},

	// this.Query an AABB for overlapping proxies, returns the user data and
	// the count, up to the supplied maximum count.
	QueryAABB: function(aabb, userData, maxCount){
		var lowerValues = new Array();
		var upperValues = new Array();
		this.ComputeBounds(lowerValues, upperValues, aabb);

		var lowerIndex = 0;
		var upperIndex = 0;
		var lowerIndexOut = [lowerIndex];
		var upperIndexOut = [upperIndex];
		this.Query(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2*this.m_proxyCount, 0);
		this.Query(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2*this.m_proxyCount, 1);

		//b2Settings.b2Assert(this.m_queryResultCount &lt; b2Settings.b2_maxProxies);

		var count = 0;
		for (var i = 0; i &lt; this.m_queryResultCount &amp;&amp; count &lt; maxCount; ++i, ++count)
		{
			//b2Settings.b2Assert(this.m_queryResults[i] &lt; b2Settings.b2_maxProxies);
			var proxy = this.m_proxyPool[ this.m_queryResults[i] ];
			//b2Settings.b2Assert(proxy.IsValid());
			userData[i] = proxy.userData;
		}

		// Prepare for next query.
		this.m_queryResultCount = 0;
		this.IncrementTimeStamp();

		return count;
	},

	Validate: function(){
		var pair;
		var proxy1;
		var proxy2;
		var overlap;

		for (var axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];

			var boundCount = 2 * this.m_proxyCount;
			var stabbingCount = 0;

			for (var i = 0; i &lt; boundCount; ++i)
			{
				var bound = bounds[i];
				//b2Settings.b2Assert(i == 0 || bounds[i-1].value &lt;= bound-&gt;value);
				//b2Settings.b2Assert(bound-&gt;proxyId != b2_nullProxy);
				//b2Settings.b2Assert(this.m_proxyPool[bound-&gt;proxyId].IsValid());

				if (bound.IsLower() == true)
				{
					//b2Settings.b2Assert(this.m_proxyPool[bound.proxyId].lowerBounds[axis] == i);
					stabbingCount++;
				}
				else
				{
					//b2Settings.b2Assert(this.m_proxyPool[bound.proxyId].upperBounds[axis] == i);
					stabbingCount--;
				}

				//b2Settings.b2Assert(bound.stabbingCount == stabbingCount);
			}
		}

	},

//private:
	ComputeBounds: function(lowerValues, upperValues, aabb)
	{
		//b2Settings.b2Assert(aabb.maxVertex.x &gt; aabb.minVertex.x);
		//b2Settings.b2Assert(aabb.maxVertex.y &gt; aabb.minVertex.y);

		//var minVertex = b2Math.b2ClampV(aabb.minVertex, this.m_worldAABB.minVertex, this.m_worldAABB.maxVertex);
		var minVertexX = aabb.minVertex.x;
		var minVertexY = aabb.minVertex.y;
		minVertexX = b2Math.b2Min(minVertexX, this.m_worldAABB.maxVertex.x);
		minVertexY = b2Math.b2Min(minVertexY, this.m_worldAABB.maxVertex.y);
		minVertexX = b2Math.b2Max(minVertexX, this.m_worldAABB.minVertex.x);
		minVertexY = b2Math.b2Max(minVertexY, this.m_worldAABB.minVertex.y);

		//var maxVertex = b2Math.b2ClampV(aabb.maxVertex, this.m_worldAABB.minVertex, this.m_worldAABB.maxVertex);
		var maxVertexX = aabb.maxVertex.x;
		var maxVertexY = aabb.maxVertex.y;
		maxVertexX = b2Math.b2Min(maxVertexX, this.m_worldAABB.maxVertex.x);
		maxVertexY = b2Math.b2Min(maxVertexY, this.m_worldAABB.maxVertex.y);
		maxVertexX = b2Math.b2Max(maxVertexX, this.m_worldAABB.minVertex.x);
		maxVertexY = b2Math.b2Max(maxVertexY, this.m_worldAABB.minVertex.y);

		// Bump lower bounds downs and upper bounds up. This ensures correct sorting of
		// lower/upper bounds that would have equal values.
		// TODO_ERIN implement fast float to uint16 conversion.
		lowerValues[0] = /*uint*/(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.minVertex.x)) &amp; (b2Settings.USHRT_MAX - 1);
		upperValues[0] = (/*uint*/(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.minVertex.x))&amp; 0x0000ffff) | 1;

		lowerValues[1] = /*uint*/(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.minVertex.y)) &amp; (b2Settings.USHRT_MAX - 1);
		upperValues[1] = (/*uint*/(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.minVertex.y))&amp; 0x0000ffff) | 1;
	},

	// This one is only used for validation.
	TestOverlapValidate: function(p1, p2){

		for (var axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];

			//b2Settings.b2Assert(p1.lowerBounds[axis] &lt; 2 * this.m_proxyCount);
			//b2Settings.b2Assert(p1.upperBounds[axis] &lt; 2 * this.m_proxyCount);
			//b2Settings.b2Assert(p2.lowerBounds[axis] &lt; 2 * this.m_proxyCount);
			//b2Settings.b2Assert(p2.upperBounds[axis] &lt; 2 * this.m_proxyCount);

			if (bounds[p1.lowerBounds[axis]].value &gt; bounds[p2.upperBounds[axis]].value)
				return false;

			if (bounds[p1.upperBounds[axis]].value &lt; bounds[p2.lowerBounds[axis]].value)
				return false;
		}

		return true;
	},

	TestOverlap: function(b, p)
	{
		for (var axis = 0; axis &lt; 2; ++axis)
		{
			var bounds = this.m_bounds[axis];

			//b2Settings.b2Assert(p.lowerBounds[axis] &lt; 2 * this.m_proxyCount);
			//b2Settings.b2Assert(p.upperBounds[axis] &lt; 2 * this.m_proxyCount);

			if (b.lowerValues[axis] &gt; bounds[p.upperBounds[axis]].value)
				return false;

			if (b.upperValues[axis] &lt; bounds[p.lowerBounds[axis]].value)
				return false;
		}

		return true;
	},

	Query: function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis){

		var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
		var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);

		// Easy case: lowerQuery &lt;= lowerIndex(i) &lt; upperQuery
		// Solution: search query range for min bounds.
		for (var j = lowerQuery; j &lt; upperQuery; ++j)
		{
			if (bounds[j].IsLower())
			{
				this.IncrementOverlapCount(bounds[j].proxyId);
			}
		}

		// Hard case: lowerIndex(i) &lt; lowerQuery &lt; upperIndex(i)
		// Solution: use the stabbing count to search down the bound array.
		if (lowerQuery &gt; 0)
		{
			var i = lowerQuery - 1;
			var s = bounds[i].stabbingCount;

			// Find the s overlaps.
			while (s)
			{
				//b2Settings.b2Assert(i &gt;= 0);

				if (bounds[i].IsLower())
				{
					var proxy = this.m_proxyPool[ bounds[i].proxyId ];
					if (lowerQuery &lt;= proxy.upperBounds[axis])
					{
						this.IncrementOverlapCount(bounds[i].proxyId);
						--s;
					}
				}
				--i;
			}
		}

		lowerQueryOut[0] = lowerQuery;
		upperQueryOut[0] = upperQuery;
	},


	IncrementOverlapCount: function(proxyId){
		var proxy = this.m_proxyPool[ proxyId ];
		if (proxy.timeStamp &lt; this.m_timeStamp)
		{
			proxy.timeStamp = this.m_timeStamp;
			proxy.overlapCount = 1;
		}
		else
		{
			proxy.overlapCount = 2;
			//b2Settings.b2Assert(this.m_queryResultCount &lt; b2Settings.b2_maxProxies);
			this.m_queryResults[this.m_queryResultCount] = proxyId;
			++this.m_queryResultCount;
		}
	},
	IncrementTimeStamp: function(){
		if (this.m_timeStamp == b2Settings.USHRT_MAX)
		{
			for (var i = 0; i &lt; b2Settings.b2_maxProxies; ++i)
			{
				this.m_proxyPool[i].timeStamp = 0;
			}
			this.m_timeStamp = 1;
		}
		else
		{
			++this.m_timeStamp;
		}
	},

//public:
	m_pairManager: new b2PairManager(),

	m_proxyPool: new Array(b2Settings.b2_maxPairs),
	m_freeProxy: 0,

	m_bounds: new Array(2*b2Settings.b2_maxProxies),

	m_queryResults: new Array(b2Settings.b2_maxProxies),
	m_queryResultCount: 0,

	m_worldAABB: null,
	m_quantizationFactor: new b2Vec2(),
	m_proxyCount: 0,
	m_timeStamp: 0};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.BinarySearch = function(bounds, count, value)
	{
		var low = 0;
		var high = count - 1;
		while (low &lt;= high)
		{
			var mid = Math.floor((low + high) / 2);
			if (bounds[mid].value &gt; value)
			{
				high = mid - 1;
			}
			else if (bounds[mid].value &lt; value)
			{
				low = mid + 1;
			}
			else
			{
				return /*uint*/(mid);
			}
		}

		return /*uint*/(low);
	};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
